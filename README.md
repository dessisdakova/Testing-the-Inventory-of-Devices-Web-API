# Testing the Inventory of Devices Web API

## Objective
- Familiarize yourself with a Flask-based web API project.
- Understand the Docker and Docker Compose configuration used in the project.
- Interact with the Inventory of Devices API to understand its functionality.
- Develop test cases for this API (manual testing, no automation required yet).

## Tasks
## 1. Clone the project repository
- URL: https://github.com/waad19/mock-api-server

## 2. Understand Docker and Docker Compose configuration
- Understand the services defined in docker-compose.yml.

```
build: .
```
Builds the Docker container using the Dockerfile in the current directory (.). This tells Docker to use the configuration in the Dockerfile located in the directory where docker-compose.yml is located.
```
container_name: {example name}
```
Sets the container name.
```
depends_on:
```
Sets dependencies between services. In this case **tests** container depends on **api-mock** container.
```
condition: service_started
```
Ensures that **api-mock** container will be running before **tests** container starts.</br>
```
environment:
```
Sets environment variables for the container. It this case *REQUESTS_CA_BUNDLE* is set to point to */root/ca/rsa/volumed_dir/full-chain.cert.pem* which tells the requests library in Python to use a custom certificate bundle for SSL verification.</br>
```
working_dir: {/example/dir}
```
Sets the working directory inside the container. Any commands that are run in the container (such as when starting the application) will be executed from this directory.</br>
```
volumes:
```
Mechanism for persisting data generated by and used by Docker containers, shared across containers or saved even if the container is stopped and restarted. In this case *.:/opt/project* mounts the current dir from local machine to */opt/project* inside the container (allows the container to access the local project files) and *api_mock_certs* volume is mounted to */root/ca/rsa/volumed_dir directory* in both the api-mock and tests containers where the server's certificates are stored.</br>
```
entrypoint:
```
Specifies the command to run when the container starts. In this case entrypoint for the container is a *ping* command to the *api-mock-server* container. It will ping the mock server *5* times to check if it is reachable.</br>
```
ports:
```
Maps port *HOST_PORT*:*CONTAINER_PORT*. In this case port 80 inside the container (the default HTTP port) is mapped to port 8080 on host machine and port 443 inside the container (the default HTTPS port) is mapped to port 8443 on host machine.</br>
```
volumes:
```
(section below `services`) - defines a volume called *api_mock_certs* that is shared between the **tests** and **api-mock** services.</br>
- Note how the web server is containerized and how it interacts with other services.

The web server (the api-mock container) is built and run inside a Docker container. It uses the `Dockerfile` to build the container image and then runs the mock API application. The container uses application defined in the `main.py` file. This mock server listens for HTTP/HTTPS requests on ports 80 and 443, respectively, and responds based on predefined API requests defined in `inventory_devices.py` and `inventory_files.py`. SSL certificates are provided to the web server through a mounted volume (api_mock_certs). </br>
The `api-mock` container provides the mock API server. The `tests` container depends on the `api-mock` container to be up and running before it starts running tests. The two containers communicate using internal Docker networking. By default, all containers within the same Docker Compose file are part of the same network and can access each other using the service name as the hostname.
- Identify the exposed ports and environment variables.

The `api-mock` container is configured to expose two ports, 80 (HTTP) and 443 (HTTPS), which are then mapped to ports 8080 and 8443 on the host machine respectively. This allows external access to the mock server via these ports on the host.</br>
The `tests` container sets the `REQUESTS_CA_BUNDLE` environment variable to specify a custom certificate bundle for SSL verification.
	
## 3. Set up and run the application
- Install Docker and Docker Compose if not already installed. ✓</br>
- Verify the application is running: Use a tool like curl or Postman. ✓</br>

## 4. Interact with the Inventory of Devices API
- Identify the available API endpoints related to the inventory of devices.

There are two available endpoints: '**/inventory/devices**' and '**/guids**' with the following requests implemented:
### GET /inventory/devices
	- Headers: none explicitly mentioned, so default headers are used
	- Body: none
	- Response body (retrieved from `inventory_devices.json`): 
 		[
		    object1,
	 	    object2
		]
	- Response status code (retrieved from `inventory_devices.json`): 200 / may be changed
### PUT /inventory/devices
	- Headers: none explicitly mentioned, so default headers are used
	- Body: JSON object containing "body" and "status_code"
	- Response body: 
 		{
   		    "new_body": [
     			body
		    ],
		    "new_status_code": status_code
		}
	- Response status code: 200
 	- Purpose: Updates the default_inventory_devices_response, which the GET request later uses.
### POST /guid/add
	- Headers: none explicitly mentioned, so default headers are used
 	- Path Parameter: guid - The GUID to be added is passed as part of the URL path. Example: /12345/add
	- Body: none
	- Response body (retrieved and updated from guid_add.json):
	 	{
		    "guid": [
			guid
		    ]
		}
	- Response status code (retrieved from guid_add.json): 200
 	- Purpose: Adds guid to guid list in memory.
### GET /guids
	- Headers: none explicitly mentioned, so default headers are used
	- Body: none
	- Response body (retrieved from `guid_add.json`): 
		{
		    "guid": [
		        currently saved guids
		    ]
		}
	- Response status code (retrieved from `guid_add.json`): 200
### PUT /guid/add
	- Headers: none explicitly mentioned, so default headers are used

- Analyze the request and response formats.</br>

## 5. Develop test cases for the Inventory of Devices API
- Write at least 5 test cases.</br>
- Focus on both positive and negative scenarios.</br>
- Consider edge cases and input validation, if applicable.</br>
- Test case format.</br>
